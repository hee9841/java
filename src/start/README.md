# [김영한의 자바 입문]() 내용 정리

<!-- TOC -->
* [1. Java 기초 (세션 1 ~ 2)](#1-java-기초-세션-1--2)
  * [자바란?](#자바란)
  * [어떤 JDK 버전을 사용해야 할까?](#어떤-jdk-버전을-사용해야-할까)
  * [컴파일 실행 과정](#컴파일-실행-과정)
  * [자바와 운영체제의 독립성](#자바와-운영체제의-독립성)
* [3. 변수](#3-변수)
    * [변수 선언 초기화](#변수-선언-초기화)
    * [리터럴](#리터럴)
    * [자주 사용하는 타입](#자주-사용하는-타입)
* [4. 연산자](#4-연산자)
* [5. 조건문](#5-조건문)
* [6. 반복문](#6-반복문)
* [7. 스코프, 형변환](#7-스코프-형변환)
  * [스코프](#스코프)
  * [형변환](#형변환)
* [8. Scanner && 훈련](#8-scanner--훈련)
* [9. 배열](#9-배열)
* [10. 정리해야 할 부분](#10-정리해야-할-부분)
<!-- TOC -->

# 1. Java 기초 (세션 1 ~ 2)
## 자바란?
자바 표준 스팩 : 컴파일러, 실행 라이브러링, jvm 에대한 스펙이 있음, JCP(자바 커뮤니티 프로세스)를 통해 관리

표준 스팩에 따라 자바를 구현체
- 여러 회사에서 : 오라클 jdk, Adoptum eclpice .., amazon...
- 예를 들어 Amazon Corretto는 AWS에 잘 작동 되도록 최적화 된 자바

장점
- 표준 스팩에 따라 되어 있어서 변경해도 괜찮음

## [어떤 JDK 버전을 사용해야 할까?](https://whichjdk.com/ko/)
### Java 애플리케이션을 빌드하고 실행하려면 필요한 것들
- Java 컴파일러 (Java 플랫폼과 표준스팩(Java SE)를 구현하는)
- 런타임 라이브러리
- JVM

### Open JDK
- java SE 스펙 오픈 소스 참조 구현(그저 소스 코드)
- 여러 OS와 같은 플랫폼을 지원하는 바이너리 형태의 배포판은 각 밴더로 부터 제공됨

### Release
- JDK 릴리즈 모델은 6개월 마다, 새로운 메이저 버전 번호가 포함된 새로운 Feature 릴리즈가 계획
- 매 2년마다 9월에 하는 릴리즈(Long-Term-Support), LTS은 릴리즈 이후 최소 3년간 업데이틀 받음
- LTS (8, 11, 17, 21)
- JDK 선택시 -> **`LTS 버전을 사용하는 걸 추천`**
    - (1) 최신 LTS 버전을 계속 사용할지
    - (2) 최신 릴리즈를 사용하고 6개월마다 업그레이드할지.
- OpenJDK는 소스코드, 스펙, 메일링 리스트 등을 확이할 수 는 있지만, 다운로드 할 수 있는 빌드는 없음 -> 그래서 배포판을 선택해야함
- 배포판 : 오라클 OpenJDK, 오라클 Java SE Development Kit(JDK), Azul Zulu, Amazon Corretto, ..


### 추천 배포판
- Azul Zulu
- Amazon Corretto : AWS의 Amazon Linux 2에서 배포할 경우
- Adoptium Eclipse Temurin : Eclipse 재단 프로젝트

### JDK와 JRE의 차이점
- 일부 배포판은 JDK(Java Development Kit)와 JRE(Java Runtime Environment) 빌드를 제공함
- JDK
  - Java 애플리케이션을 컴파일, 패키징 및 실행 하기 위한 모든 것이 포함되어있음
- JRE
  - Java 애플리케이션을 실행 하기 위한 바이너리와 라이브러리만 포함되어 있음
- JRE는 JDK의 축소 버전으로, 메가바이트 단위로 더 작음
- 크기가 중요한 경우 jlink를 사용하여 자체적으로 축소된 런타임을 생성하는 것을 고려
- 로컬 환경 개발에는 JDK가 필요합니다. 프로덕션 환경에서는 런타임 환경만 필요하지만 JDK를 사용하는 경우도 매우 일반적

### Java EE 란
- Java EE (Java Platform, Enterprise Edition) 는 Jakarta EE 로 이름을 변경
- Jakarta EE는 서버 애플리케이션과 프론트엔드를 구축하기 위한 스펙
- Jakarta EE는 Spring Boot, Micronaut, Quarkus와 같은 최신 프레임워크와 비교할 수 있지만, Jakarta EE가 더 복잡하게 느껴집니다.

## 컴파일 실행 과정
1. .java 코드를 작성
2. 자바 컴파일러를 사용해 코드를 컴파일
    - javac(자바가 제공하는) 프로그램을 사용
    - .java -> .class 파일로 생성
    - 자바 소스 코드를 바이트코ㅡ드로 변환 -> 자바 가상머신(JVM)에서 더 빠르게 실행될 수 있게 최적화, 오류 검출
3. 자바 프로그램을 실행
    - 자바 제공하는 `java`라는 프로그램 사용
    - 자바 가상 머신(JVM)이 실행되면서 프로그램 작동(class 파일 읽음)

### 인텔리제이를 통한 컴파일, 실행과정
1. 컴파일
    - 자바 코드 컴파일을 하기 위해서 `javac`를 사용해서 컴파일(예전에 처음 배웠을 때 콘솔에서 javac 명령어로 컴파일 했었음)
        - ex) javac Hello.java
    - 인텔리제이는 자바코드 실행할 때 이 과정을 자동으로 실행
    - out 폴더에 가보면 컴파일된 .class 파일이있음. 그리고 클래스 파일(바이트코드로)에는 주석이 없음(디컴파일 되어있는거 보면)
2. 실행
    - `java` 명령어(프로그램)을 사용해 실행, 컴파일된 파일을 지정(확장자는 제외)
        - ex) java Hello

3. 인텔리제이에서
    - 자바 코드를 실행하면 컴파일과 실행이 한번에 처리됨

## 자바와 운영체제의 독립성
> 일반적인 프로그램은 다른 OS에서 실행할 수 없음(윈도우 프로그램은 mac, linux에서 호환X)

- 자바는 자바가 설취된 OS에서 실행 할 수 있음
- 특정 OS에 맞춰서 개발하지 않아도 됨
- OS 호환성은 java에서 해결

### 개발과 운영환경
- 개발자는 윈도우나 맥 사용, 파일 컴파일 -> 리눅스 OS 에서 컴파일 파일 실행

# 3. 변수
### 변수 선언 초기화
- 변수를 선언: 컴퓨터에서 메모리 공간을 확보해 그곳에 데이터 저장, 변수이름(주소값)으로 메모리공간 접근한다.
- 지역변수는 직접 초기화해야함.
- 클래스, 인스턴스 변수 등은 자바가 나중에 자동으로 초기화해줌

### 리터럴
- 개발자가 직접 적은 `100`, `10.5`, `'A'`, `"Hello Java"`와 같은 고정된 값을 프로그래밍 용어로 리터럴(literal) 이라고 한다.
- 변수 값은 변할 수 있지만 리터럴은 개발자가 입력한 고정된 값, 리터럴 자체는 변하지 않음
- 데이터(값) 그 자체를 뜻한다. 즉, 변수에 넣는 변하지 않는 데이터

### 자주 사용하는 타입
- 정수 : int, long (대신 파일 다룰 때는 byte)
- 실수 : double
- 불린형 boolean (true, false)
- 문자열 : String


# 4. 연산자
## 연산자 우선 순위
1. 괄호 ()
2. 단항 연산자 (++, --, !, ~, new, (type))
3. Shift 연산자(<<, >>)
4. 비교 연산자 (<. <=, >, >=. instanceof)
5. 등식 연산자(==, !=)
6. 비트 연산자(&, ^, |)
7. 논리 연산자(&&, ||)
8. 삼항
9. 대입 연산자(-, +=,..)

### 외우는 방법??
1. 상식선에서 우선 순위를 사용하자
2. 애매하면 ()를 사용하자
- 연산자 우선순위는 상식선에서 생각하고, 애매하면 괄호를 사용하자.
- 누구나 코드를 보고 쉽고 명확하게 이해할 수 있어야 한다. 개발자들이 연산자 우선순위를 외우고 개발하는 것이
  아니다! 복잡하면 명확하게 괄호를 넣어라!
- 개발에서 가장 중요한 것은 단순함과 명확함이다! 애매하거나 복잡하면 안된다.

## 증감 연산자
## 전위, 후위 증감 연산
- ++a : 전위, 증감 연산이 먼저 수행된 후 다른 연산 실행
- a++ : 후위, 다른 연산이 먼저 수행된 후 증감 연산이 수행

## 비교 연산자
- 두 값을 비교하는데 사용,
- 주로 조건문과 함께 사용


# 5. 조건문

## Java 14 이후 새로운 Switch 문
```
// 이전
switch (grade) {
    case "A" :
        System.out.println("탁월한 성과입니다!");
        break;
    case "B":
        System.out.println("좋은 성과입니다!");
        break;
    case "C":
        System.out.println("준수한 성과입니다!");
        break;
    case "D":
        System.out.println("향상이 필요합니다.");
        break;
    case "F":
        System.out.println("불합격입니다.");
        break;
    default:
        System.out.println("잘못된 학점입니다.");
}

// 이후
switch (grade) {
    case "A" -> System.out.println("탁월한 성과입니다!");
    case "B" -> System.out.println("좋은 성과입니다!");
    case "C" -> System.out.println("준수한 성과입니다!");
    case "D" -> System.out.println("향상이 필요합니다.");
    case "F" -> System.out.println("불합격입니다.");
    default -> System.out.println("잘못된 학점입니다.");
}

```

# 6. 반복문
정리할 내용 없음

# 7. 스코프, 형변환
## 스코프
지역 변수와 스코프
- 멤버 변수(클래스 변수, 인스턴스 변수)
- 지역 변수(로컬 변수)
- 특정 지역에서만 사용할 수 있는 변수

스코프 존재 이유
- 비효율 적인 메모리 사용 줄이기
- 코드 복잡성 감소

>  **좋은 프로그램은 무한한 자유가 있는 프로그램이 아니라 적절한 제약이 있는 프로그램이다.**

## 형변환
- 작은 범위 -> 큰범위 : 당연히 값을 넣을  수 있음
    - ex) int -> long -> double
    - 자동 형변환, 묵시적 형변환 : 자동으로 형 변환이 됨
    - ex) 
    ```
        int intVale = 5;
        double doubleVal = intVale;
    ```
- 큰 범위 -> 작은 범위 : 명시적 형변환으로 변환
  - 아래 문제가 발생
      - 소수점 버림
      - 오버플로우

연산과 형변환
1. 같은 타입의 계산은 같은 타입의 결과를 나타냄
2. 서로 다른 타입은 큰 범위로 자동 형변환


# 8. Scanner && 훈련
## Scanner의 개행 문자 문제((\n leftover)
- Scanner을 사용해서, 콘솔 입력을 처리할 때 발생하는 문제 중 하나
-  nextLine()과 next(), nextInt(), nextDouble() 등 다른 Scanner 메서드를 함께 사용할 때 문제가 발생 된다.

### 문제 발생 이유
- Scanner의 메서드 중 일부는 공백(스페이스, 탭, 개행 등) 기준으로 입력을 분리하고, 개행 문자(\n)는 무시하는 경우가 있음
  - nextInt(), nextDouble(), next()등
- 위의 메서드(nextInt(), nextDouble(), next())로 입력을 받고 -> nextLine()을 입력 받으면
  - 남아 있는 개행 문자(\n)을 받고, 그 줄이 끝났다고 판단해서 빈 문자열을 반환한다.

### 해결 방법
1. nextLine()를 한번 더 호출
2. 가능하면 모두 nextLine()으로 읽고, 필요한 형으로 파싱하는 방법
```java
int num = Integer.parseInt(sc.nextLine());
String line = sc.nextLine();
```

# 9. 배열
정리할 내용 없음

# 10. 메서드
### 인수(Argument)
- 넘기는 값
- ex `call("hello" , 20);` 에서 hello, 20이 인수

### 파라미터(매개변수)
- 메서드 정의할 때 선언한 변수
- public void call(String name, int age) 에서 `name`, `age`

### 메서드 정의
```java
public static int add(int a, int b) {
 //메서드 본문, 실행 코드
}

제어자 반환타입 메서드이름(매개변수 목록) {
    // 메서드 본문
}
```
- 제어자(Modifier) : public , static 과 같은 부분
- 반환 타입(Return Type)
- 메서드 이름(Method Name)
- 매개변수(Parameter)
- 메서드 본문(Method Body)

### 변수와 값 복사
**자바는 항상 변수의 값을 복사해서 대입한다.**
- 메서드의 매개변수의 값은 복사해서 전달함.
- 참조형도 참조값을 복사해서 전달한다.

### 메서드와 형변환
매개변수가 큰값(ex. double) 이고 인자가 작은 값이면(int)면 자동 형변환된다.

### 메서드 오버로딩
메서드 시그니처(method signature)가 다르면 오버로딩 가능하다.

메서드 시그니처(method signature)
-  메서드를 구분할 수 있는 고유한 식별자나 서명
- 메서드 이름 + 매개변수 타입(순서, 개수)

## 메서드 사용의 장점
- 코드 재사용
- 코드 가독성
- 모듈성
- 코드 유지관리
- 재사용성과 확장성
- 추상화
- 테스트와 디버깅 용의성

# 10. 정리해야 할 부분
> todo
> 
>  - [ ] 지역변수는 직접 초기화해야함
>  - [ ] 클래스, 인스턴스 변수 등은 자바가 나중에 자동으로 초기화해줌
>  
>  - [ ] float, 클래스 타입 정리
>  - [ ] 패키지관련
>  - [ ] 변수의 초기화 관련...어떤 변수는 자바에서 자동 초기화 된다.
>  - [ ] 지역 변수, 초기화 관련(값을 할당 하는 것)
>  - [ ] 동등성과 멱등성

